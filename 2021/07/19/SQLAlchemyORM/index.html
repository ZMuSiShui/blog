<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SQLAlchemy ORM 学习笔记"><meta name="keywords" content="学习笔记,Python"><meta name="author" content="Jie"><meta name="copyright" content="Jie"><title>SQLAlchemy ORM 学习笔记 | JieのBlog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="JieのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-Relational-Tutorial"><span class="toc-number">1.</span> <span class="toc-text">Object Relational Tutorial</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BVersion"><span class="toc-number">2.1.</span> <span class="toc-text">查看Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%98%A0%E5%B0%84"><span class="toc-number">2.3.</span> <span class="toc-text">声明映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.4.</span> <span class="toc-text">创建模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%98%A0%E5%B0%84%E7%B1%BB%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">创建映射类实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D"><span class="toc-number">2.6.</span> <span class="toc-text">创建会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%92%8C%E6%9B%B4%E6%96%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.</span> <span class="toc-text">添加和更新对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-Query"><span class="toc-number">3.</span> <span class="toc-text">查询(Query)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84filter%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">常用的filter操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8-List-%E5%92%8C%E5%8D%95%E9%A1%B9-Scalar"><span class="toc-number">3.2.</span> <span class="toc-text">返回列表(List)和单项(Scalar)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E4%BD%BF%E7%94%A8SQL"><span class="toc-number">3.3.</span> <span class="toc-text">嵌入使用SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">计数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB-Relationship"><span class="toc-number">4.</span> <span class="toc-text">关系(Relationship)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">建立关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.</span> <span class="toc-text">使用关联对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#joinedload"><span class="toc-number">4.2.1.</span> <span class="toc-text">joinedload</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8join%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.3.</span> <span class="toc-text">使用join进行查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D"><span class="toc-number">4.4.</span> <span class="toc-text">使用别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2-Subqueries"><span class="toc-number">4.4.1.</span> <span class="toc-text">使用子查询(Subqueries)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%AD%E5%8F%96%E5%87%BAEntity"><span class="toc-number">4.4.2.</span> <span class="toc-text">从子查询中取出Entity</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8EXISTS"><span class="toc-number">4.5.</span> <span class="toc-text">使用EXISTS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">4.6.</span> <span class="toc-text">常用的关系操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Eager-Loading"><span class="toc-number">4.7.</span> <span class="toc-text">Eager Loading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.7.1.</span> <span class="toc-text">子查询加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.7.2.</span> <span class="toc-text">连接加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%9A%84Join-EagerLoad"><span class="toc-number">4.7.3.</span> <span class="toc-text">显式的Join + EagerLoad</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E9%97%AE%E9%A2%98"><span class="toc-number">4.8.</span> <span class="toc-text">关系中的删除问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEdelete-delete-orphan-Cascade"><span class="toc-number">4.8.1.</span> <span class="toc-text">配置delete&#x2F;delete-orphan Cascade</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BBManyToMany-Relationship"><span class="toc-number">4.9.</span> <span class="toc-text">建立多对多关系ManyToMany Relationship</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/logo.png"></div><div class="author-info__name text-center">Jie</div><div class="author-info__description text-center">记录点滴小事</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">19</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Tools</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://zhangjie.me">Me</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.zmusishui.workers.dev">Github 下载加速</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://wiki.zmusishui.workers.dev">Wiki 百科(中文)</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">JieのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">SQLAlchemy ORM 学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python/">Python</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Object-Relational-Tutorial"><a href="#Object-Relational-Tutorial" class="headerlink" title="Object Relational Tutorial"></a>Object Relational Tutorial</h2><p>所谓ORM（Object Relational Mapping），就是建立其由Python类到数据库表的映射关系：一个Python实例(<em>instance</em>) 对应数据库中的一行(<em>row</em>)。</p>
<p>这种映射包含两层含义，一是实现对象和与之关联的的行的状态同步，二是将涉及数据库的查询操作，表达为 Python 类的相互关系。</p>
<p>注意 ORM 和 SQLAlchemy 的 Expression Language 不同。后者可以视为对原始SQL的封装。ORM是基于Expression Language 而构建的，其抽象层次要高于 Expression Language。很多时候都是使用ORM，有时需要一些高度定制化的功能时，就需要使用到 Expression Language。</p>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="查看Version"><a href="#查看Version" class="headerlink" title="查看Version"></a>查看Version</h3><p>可以用下面的命令来查看 SQLAlchemy 的版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlalchemy.__version___</span><br><span class="line"><span class="number">1.4</span><span class="number">.20</span></span><br></pre></td></tr></table></figure>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>engine = create_engine(<span class="string">&#x27;sqlite:///:memory:&#x27;</span>, echo=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>echo</code> 设置为True可以使得后面可以在控制台看到操作涉及的 SQL 语言。</p>
<p><code>create_engine</code> 返回的是一个 <code>Engine</code> 实例，它代表了指向数据库的一些非常核心的接口。他会根据你选择的数据库配置而调用对应的 <code>DBAPI</code>。</p>
<p>当第一次如 <code>Engine.execute()</code> 或者 <code>Engine.connect()</code> 的方法被调用时，<code>Engine</code> 才会真正的建立起到数据库的 <code>DBAPI</code> 连接。实际上，一般并不会直接使用 <code>Engine</code>。</p>
<h3 id="声明映射"><a href="#声明映射" class="headerlink" title="声明映射"></a>声明映射</h3><p>当使用 ORM 的时候，其配置过程主要分为两个部分：</p>
<ol>
<li><p>描述我们要处理的数据库表的信息，</p>
</li>
<li><p>将我们的Python类映射到这些表上。</p>
</li>
</ol>
<p>这两个过程在 SQLAlchemy 中是一起完成的，这个过程称之为 <strong>Declarative</strong>。</p>
<p>使用 Declarative 参与 ORM 映射的类需要被定义成为一个指定基类的子类，这个基类应当含有ORM映射中相关的类和表的信息。这样的基类称之为<strong>declarative base class</strong>。在应用中，一般只需要一个这样的基类。这个基类可以通过 <code>declarative_base</code> 来创建</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Base = declarative_base()</span><br></pre></td></tr></table></figure>
<p>现在已经有了一个基类，就可以基于这个基类来创建自定义类了。以建立一个用户类为例子。从 <code>Base</code> 派生一个名为 <code>User</code> 的类，在这个类里面可以定义将要映射到数据库的表上的属性（主要是表的名字，列的类型和名称等）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    fullname = Column(String)</span><br><span class="line">    password = Column(String)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;User(name=&#x27;%s&#x27;, fullname=&#x27;%s&#x27;, password=&#x27;%s&#x27;)&gt;&quot;</span> % (</span><br><span class="line">                             self.name, self.fullname, self.password)</span><br></pre></td></tr></table></figure>
<p>通过 Declarative 生成的类至少应该包含一个名为 <strong>tablename</strong> 的属性来给出目标表的名称，以及至少一个<code>Column</code> 来给出表的主键( Primary Key )。SQLAlchemy 不会对于类名和表名之间的关联做任何假设，也不会自动涉及数据类型以及约束的转换。一般可以自己创建一个模板来建立这些自动转换，这样可以减少很多重复劳动。</p>
<p>当类声明完成后，Declarative 将会将所有的 <code>Column</code> 成员替换成为特殊的 Python 访问器( accessors )，这称之为 <strong>descriptors</strong>。这个过程称为 <strong>instrumentation</strong>，经过 instrumentation 的映射类可以读写数据库的表和列。</p>
<p><strong>注意除了这些涉及ORM的映射意外，这些mapping类的其他部分仍然是不变的。</strong></p>
<h3 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h3><p>通过 Declarative 系统构建好 <code>User</code> 类之后，与之同时的关于表的信息也已经创建好了，其称之为 <strong>table metadata</strong>。描述这些信息的类为 <code>Table</code>。可以通过 <code>__table__</code> 这个类变量来查看表信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.__table__ </span><br><span class="line">Table(<span class="string">&#x27;users&#x27;</span>, MetaData(bind=<span class="literal">None</span>),</span><br><span class="line">            Column(<span class="string">&#x27;id&#x27;</span>, Integer(), table=&lt;users&gt;, primary_key=<span class="literal">True</span>, nullable=<span class="literal">False</span>),</span><br><span class="line">            Column(<span class="string">&#x27;name&#x27;</span>, String(), table=&lt;users&gt;),</span><br><span class="line">            Column(<span class="string">&#x27;fullname&#x27;</span>, String(), table=&lt;users&gt;),</span><br><span class="line">            Column(<span class="string">&#x27;password&#x27;</span>, String(), table=&lt;users&gt;), schema=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>当完成类声明时，Declarative 用一个 Python 的 metaclass 来为这个类进行了加工。在这个阶段，它依据给出的设置创建了 <code>Table</code> 对象，然后构造一个 <code>Mapper</code> 对象来与之关联。</p>
<p><code>Table</code> 对象是一个更大家庭—- <code>MetaData</code> —-的一部分。当使用 Declarative 时，这个对象也可以在 Declarative base class 的 <code>.metadata</code> 属性中看到。</p>
<p><code>MetaData</code> 是与数据库打交道的一个接口。对于的SQLite数据库而言，此时还没有一个名为<code>users</code>的表的存在，这时需要使用 <code>MetaData</code> 来发出 <code>CREATE TABLE</code> 的命令。下面使用 <code>MetaData.create_all()</code> 指令，将上面得到的 <code>Engine</code> 作为参数传入。如果上面设置了 echo 为 True 的话，应该可以看到这一过程中的SQL指令。首先检查了 <code>users</code> 表的存在性，如果不存在的话会执行表的创建工作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Base.metadata.create_all(engine)</span><br><span class="line">SELECT ...</span><br><span class="line">PRAGMA table_info(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">()</span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    <span class="built_in">id</span> INTEGER NOT NULL, name VARCHAR,</span><br><span class="line">    fullname VARCHAR,</span><br><span class="line">    password VARCHAR,</span><br><span class="line">    PRIMARY KEY (<span class="built_in">id</span>)</span><br><span class="line">)</span><br><span class="line">()</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<h3 id="创建映射类实例"><a href="#创建映射类实例" class="headerlink" title="创建映射类实例"></a>创建映射类实例</h3><p>创建 <code>User</code> 对象十分简单</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user = User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;edspassword&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user.name</span><br><span class="line"><span class="string">&#x27;ed&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user.password</span><br><span class="line"><span class="string">&#x27;edspassword&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(ed_user.<span class="built_in">id</span>)</span><br><span class="line"><span class="string">&#x27;None&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><p>Session 是一个非常重要的概念，类似于iOS中的 NSManagedContext 的概念。</p>
<p>现在可以和数据库对话了。ORM 对数据库的入口即是 <code>Session</code>，当构建应用时，和 <code>create_engine</code> 的同一级别下，定义一个 <code>Session</code> 类来作为生成新的 Session 的 Factory 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Session = sessionmaker(bind=engine)</span><br></pre></td></tr></table></figure>
<p>当试图在定义 <code>Engine</code> 之前定义 <code>Sesssion</code> 的话，这里的 <code>bind</code> 可以不设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Session = sessionmaker()</span><br></pre></td></tr></table></figure>
<p>后续定义好 <code>Engine</code> 后可以通过 <code>configure()</code> 来将其连接到 <code>Session</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Session.configure(bind=engine)  <span class="comment"># once engine is available</span></span><br></pre></td></tr></table></figure>
<p>这个自定义的工厂类就可以拿来构造新的 <code>Session</code> 了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session = Session()</span><br></pre></td></tr></table></figure>
<p>上面的 <code>Session</code> 已经和 SQLite 的数据库的 <code>Engine</code> 关联起来了，但是可以发现它还没有打开任何到数据库的连接( connection )。当一个 <code>Session</code> 被首次使用时，它会从 <code>Engine</code> 所维护的连接池中取出一个连接来操作数据库。这个连接在应用有所更改或者关闭 <code>Session</code> 时会被释放。</p>
<h3 id="添加和更新对象"><a href="#添加和更新对象" class="headerlink" title="添加和更新对象"></a>添加和更新对象</h3><p>为了将 <code>User</code> 对象存入数据库，可以调用 <code>Sesson</code> 的 <code>add()</code> 函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user = User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;edspassword&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(ed_user)</span><br></pre></td></tr></table></figure>
<p>当这个操作完成之后，这个 <code>User</code> 实例的状态为 <strong>pending</strong>。目前实际上还没有执行SQL操作，也就是说数据库中还没有产生和这个 <code>User</code> 实例对应的行。<code>Session</code> 将会在需要的时候执行相应的SQL命令，这个过程称之为<strong>flush</strong>。如果试图查询 <code>Ed Jones</code>，所有处于 <code>pending</code> 状态的信息将会首先被 <strong>flush</strong>，然后负责进行查询的 SQL 语言在此之后立即被执行。</p>
<p>例如，创建一个查询来获取刚刚创建的用户。这个查询会返回一个和之前添加的用户相同的用户实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>our_user = session.query(User).filter_by(name=<span class="string">&#x27;ed&#x27;</span>).first()</span><br><span class="line">BEGIN (implicit)</span><br><span class="line">INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)</span><br><span class="line">(<span class="string">&#x27;ed&#x27;</span>, <span class="string">&#x27;Ed Jones&#x27;</span>, <span class="string">&#x27;edspassword&#x27;</span>)</span><br><span class="line">SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">        users.name AS users_name,</span><br><span class="line">        users.fullname AS users_fullname,</span><br><span class="line">        users.password AS users_password</span><br><span class="line">FROM users</span><br><span class="line">WHERE users.name = ?</span><br><span class="line"> LIMIT ? OFFSET ?</span><br><span class="line">(<span class="string">&#x27;ed&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>our_user</span><br><span class="line">&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;edspassword&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>事实上这里的 <code>Session</code> 判断出来了需要返回的行和已经存在内存中的一个映射实例应当是同一个，所以会得到一个和之前完全相同的实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user <span class="keyword">is</span> our_user</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这里ORM所表现的理念，称之为 <a target="_blank" rel="noopener" href="http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-identity-map">identity map</a>。这个设计理念保证了在一个 <code>Session</code> 对于一个制定行的操作，作用于同一个内存实例上。当一个拥有特定主键的对象出现在 <code>Session</code> 中时，所有的查询操作对这个主键都会返回一个相同的 Python 对象。并且，如果试图引入重复了主键的新的对象时，系统会产生一个错误来阻止你的操作。</p>
<p>可以通过 <code>add_all()</code> 来一次加入多个对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.add_all([</span><br><span class="line"><span class="meta">... </span>    User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    User(name=<span class="string">&#x27;mary&#x27;</span>, fullname=<span class="string">&#x27;Mary Contrary&#x27;</span>, password=<span class="string">&#x27;xxg527&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>    User(name=<span class="string">&#x27;fred&#x27;</span>, fullname=<span class="string">&#x27;Fred Flinstone&#x27;</span>, password=<span class="string">&#x27;blah&#x27;</span>)])</span><br></pre></td></tr></table></figure>
<p>并且，如果希望改变Ed的密码，可以直接修改之：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user.password = <span class="string">&#x27;f8s7ccs&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这个修改会被 <code>Session</code> 记录下来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.dirty</span><br><span class="line">IdentitySet([&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;f8s7ccs&#x27;</span>)&gt;])</span><br></pre></td></tr></table></figure>
<p>当然，上面的插入操作也被记录了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.new </span><br><span class="line">IdentitySet([&lt;User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>)&gt;,</span><br><span class="line">&lt;User(name=<span class="string">&#x27;mary&#x27;</span>, fullname=<span class="string">&#x27;Mary Contrary&#x27;</span>, password=<span class="string">&#x27;xxg527&#x27;</span>)&gt;,</span><br><span class="line">&lt;User(name=<span class="string">&#x27;fred&#x27;</span>, fullname=<span class="string">&#x27;Fred Flinstone&#x27;</span>, password=<span class="string">&#x27;blah&#x27;</span>)&gt;])</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>commit()</code> 命令来将这些更改 <strong>flush</strong> 到数据库中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.commit()</span><br></pre></td></tr></table></figure>
<h2 id="查询-Query"><a href="#查询-Query" class="headerlink" title="查询(Query)"></a>查询(Query)</h2><p><code>Session</code> 的 <code>query</code> 函数会返回一个 <code>Query</code> 对象。<code>query</code> 函数可以接受多种参数类型。可以是类，或者是类的instrumented <strong>descriptor</strong>。下面的这个例子取出了所有的 <code>User</code> 记录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> instance <span class="keyword">in</span> session.query(User).order_by(User.<span class="built_in">id</span>):</span><br><span class="line"><span class="meta">... </span>    print(instance.name, instance.fullname)</span><br><span class="line">ed Ed Jones</span><br><span class="line">wendy Wendy Williams</span><br><span class="line">mary Mary Contrary</span><br><span class="line">fred Fred Flinstone</span><br></pre></td></tr></table></figure>
<p><code>Query</code> 也接受 ORM-instrumented descriptors 作为参数。当多个参数传入时，返回结果为以同样顺序排列的tuples</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, fullname <span class="keyword">in</span> session.query(User.name, User.fullname):</span><br><span class="line"><span class="meta">... </span>    print(name, fullname)</span><br><span class="line">ed Ed Jones</span><br><span class="line">wendy Wendy Williams</span><br><span class="line">mary Mary Contrary</span><br><span class="line">fred Fred Flinstone</span><br></pre></td></tr></table></figure>
<p><code>Query</code> 返回的 tuples 由 <code>KeyedTuple</code> 这个类提供，其成员除了用下标访问以外，还可以视为实例变量来获取。对应的变量的名称与被查询的类变量名称一样，如下例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> session.query(User, User.name).<span class="built_in">all</span>():</span><br><span class="line"><span class="meta">... </span>   print(row.User, row.name)</span><br><span class="line">&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;f8s7ccs&#x27;</span>)&gt; ed</span><br><span class="line">&lt;User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>)&gt; wendy</span><br><span class="line">&lt;User(name=<span class="string">&#x27;mary&#x27;</span>, fullname=<span class="string">&#x27;Mary Contrary&#x27;</span>, password=<span class="string">&#x27;xxg527&#x27;</span>)&gt; mary</span><br><span class="line">&lt;User(name=<span class="string">&#x27;fred&#x27;</span>, fullname=<span class="string">&#x27;Fred Flinstone&#x27;</span>, password=<span class="string">&#x27;blah&#x27;</span>)&gt; fred</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>label()</code> 来制定 descriptor 对应实例变量的名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> session.query(User.name.label(<span class="string">&#x27;name_label&#x27;</span>)).<span class="built_in">all</span>():</span><br><span class="line"><span class="meta">... </span>   print(row.name_label)</span><br><span class="line">ed</span><br><span class="line">wendy</span><br><span class="line">mary</span><br><span class="line">fred</span><br></pre></td></tr></table></figure>
<p>而对于类参数而言，要实现同样的定制需要使用 <code>aliased</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> aliased</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_alias = aliased(User, name=<span class="string">&#x27;user_alias&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> session.query(user_alias, user_alias.name).<span class="built_in">all</span>():</span><br><span class="line"><span class="meta">... </span>   print(row.user_alias)</span><br><span class="line">&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;f8s7ccs&#x27;</span>)&gt;</span><br><span class="line">&lt;User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>)&gt;</span><br><span class="line">&lt;User(name=<span class="string">&#x27;mary&#x27;</span>, fullname=<span class="string">&#x27;Mary Contrary&#x27;</span>, password=<span class="string">&#x27;xxg527&#x27;</span>)&gt;</span><br><span class="line">&lt;User(name=<span class="string">&#x27;fred&#x27;</span>, fullname=<span class="string">&#x27;Fred Flinstone&#x27;</span>, password=<span class="string">&#x27;blah&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>基本的查询操作除了上面这些之外，还包括 OFFSET 和 LIMIT，这个可以通过 Python 的 array slice 来完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> u <span class="keyword">in</span> session.query(User).order_by(User.<span class="built_in">id</span>)[<span class="number">1</span>:<span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>   print(u)</span><br><span class="line">&lt;User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>)&gt;</span><br><span class="line">&lt;User(name=<span class="string">&#x27;mary&#x27;</span>, fullname=<span class="string">&#x27;Mary Contrary&#x27;</span>, password=<span class="string">&#x27;xxg527&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>上述过程实际上只涉及了整体取出的操作，而没有进行筛选，筛选常用的函数是 <code>filter_by</code> 和 <code>filter</code>。其中后者比起前者要更灵活一些，可以在后者的参数中使用python的运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, <span class="keyword">in</span> session.query(User.name).filter_by(fullname=<span class="string">&#x27;Ed Jones&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>   print(name)</span><br><span class="line">ed</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, <span class="keyword">in</span> session.query(User.name).<span class="built_in">filter</span>(User.fullname==<span class="string">&#x27;Ed Jones&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>   print(name)</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>
<p>注意 <code>Query</code> 对象是 <strong>generative</strong> 的，这意味可以把他们串接起来调用，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> user <span class="keyword">in</span> session.query(User).\</span><br><span class="line"><span class="meta">... </span>         <span class="built_in">filter</span>(User.name==<span class="string">&#x27;ed&#x27;</span>).\</span><br><span class="line"><span class="meta">... </span>         <span class="built_in">filter</span>(User.fullname==<span class="string">&#x27;Ed Jones&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>   print(user)</span><br><span class="line">&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;f8s7ccs&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<p><strong>串接的 filter 之间是与的关系</strong></p>
<h3 id="常用的filter操作符"><a href="#常用的filter操作符" class="headerlink" title="常用的filter操作符"></a>常用的filter操作符</h3><p>下面的这些操作符可以应用在 <code>filter</code> 函数中</p>
<ul>
<li><p><strong>equals</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.name == <span class="string">&#x27;ed&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>not equals</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.name != <span class="string">&#x27;ed&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>like</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.name.like(<span class="string">&#x27;%ed%&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IN</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.name.in_([<span class="string">&#x27;ed&#x27;</span>, <span class="string">&#x27;wendy&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也适用于查询对象:</span></span><br><span class="line">query.<span class="built_in">filter</span>(User.name.in_(</span><br><span class="line">        session.query(User.name).<span class="built_in">filter</span>(User.name.like(<span class="string">&#x27;%ed%&#x27;</span>))</span><br><span class="line">))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>NOT IN</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(~User.name.in_([<span class="string">&#x27;ed&#x27;</span>, <span class="string">&#x27;wendy&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IS NULL</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.name == <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于, if pep8/linters are a concern</span></span><br><span class="line">query.<span class="built_in">filter</span>(User.name.is_(<span class="literal">None</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IS NOT NULL</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.name != <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于, if pep8/linters are a concern</span></span><br><span class="line">query.<span class="built_in">filter</span>(User.name.isnot(<span class="literal">None</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>AND</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_</span><br><span class="line">query.<span class="built_in">filter</span>(and_(User.name == <span class="string">&#x27;ed&#x27;</span>, User.fullname == <span class="string">&#x27;Ed Jones&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">query.<span class="built_in">filter</span>(User.name == <span class="string">&#x27;ed&#x27;</span>, User.fullname == <span class="string">&#x27;Ed Jones&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">query.<span class="built_in">filter</span>(User.name == <span class="string">&#x27;ed&#x27;</span>).<span class="built_in">filter</span>(User.fullname == <span class="string">&#x27;Ed Jones&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>OR</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> or_</span><br><span class="line">query.<span class="built_in">filter</span>(or_(User.name == <span class="string">&#x27;ed&#x27;</span>, User.name == <span class="string">&#x27;wendy&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>MATCH</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.name.match(<span class="string">&#x27;wendy&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="返回列表-List-和单项-Scalar"><a href="#返回列表-List-和单项-Scalar" class="headerlink" title="返回列表(List)和单项(Scalar)"></a>返回列表(List)和单项(Scalar)</h3></li>
</ul>
<p><code>Query </code>有很多方法执行了 SQL 命令并返回了取出的数据库结果</p>
<ul>
<li><p><strong>all() 返回一个列表</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>query = session.query(User).<span class="built_in">filter</span>(User.name.like(<span class="string">&#x27;%ed&#x27;</span>)).order_by(User.<span class="built_in">id</span>)</span><br><span class="line">SQL&gt;&gt;&gt; query.<span class="built_in">all</span>()</span><br><span class="line">[&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;f8s7ccs&#x27;</span>)&gt;,</span><br><span class="line">      &lt;User(name=<span class="string">&#x27;fred&#x27;</span>, fullname=<span class="string">&#x27;Fred Flinstone&#x27;</span>, password=<span class="string">&#x27;blah&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>first() 返回至多一个结果，而且以单项形式，而不是只有一个元素的 tuple 形式返回这个结果</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>query.first()</span><br><span class="line">&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;f8s7ccs&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>one() 返回且仅返回一个查询结果。当结果的数量不足一个或者多于一个时会报错</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user = query.one()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">MultipleResultsFound: Multiple rows were found <span class="keyword">for</span> one()</span><br></pre></td></tr></table></figure>
<p>没有查找到结果时:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user = query.<span class="built_in">filter</span>(User.<span class="built_in">id</span> == <span class="number">99</span>).one()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">NoResultFound: No row was found <span class="keyword">for</span> one()</span><br></pre></td></tr></table></figure></li>
<li><p><strong>one_or_none()：从名称可以看出，当结果数量为0时返回 None， 多于1个时报错</strong></p>
</li>
<li><p><strong>scalar() 和 one() 类似，但是返回单项而不是 tuple</strong></p>
</li>
</ul>
<h3 id="嵌入使用SQL"><a href="#嵌入使用SQL" class="headerlink" title="嵌入使用SQL"></a>嵌入使用SQL</h3><p>可以在 <code>Query</code> 中通过 <code>text()</code> 使用SQL语句。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> text</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> user <span class="keyword">in</span> session.query(User).\</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">filter</span>(text(<span class="string">&quot;id&lt;224&quot;</span>)).\</span><br><span class="line"><span class="meta">... </span>            order_by(text(<span class="string">&quot;id&quot;</span>)).<span class="built_in">all</span>():</span><br><span class="line"><span class="meta">... </span>    print(user.name)</span><br><span class="line">ed</span><br><span class="line">wendy</span><br><span class="line">mary</span><br><span class="line">fred</span><br></pre></td></tr></table></figure>
<p>除了上面这种直接将参数写进字符串的方式外，还可以通过 <code>params()</code> 方法来传递参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(User).<span class="built_in">filter</span>(text(<span class="string">&quot;id&lt;:value and name=:name&quot;</span>)).\</span><br><span class="line"><span class="meta">... </span>    params(value=<span class="number">224</span>, name=<span class="string">&#x27;fred&#x27;</span>).order_by(User.<span class="built_in">id</span>).one()</span><br><span class="line">&lt;User(name=<span class="string">&#x27;fred&#x27;</span>, fullname=<span class="string">&#x27;Fred Flinstone&#x27;</span>, password=<span class="string">&#x27;blah&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>并且，可以直接使用完整的SQL语句，但是要注意将表名和列明写正确。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(User).from_statement(</span><br><span class="line"><span class="meta">... </span>                    text(<span class="string">&quot;SELECT * FROM users where name=:name&quot;</span>)).\</span><br><span class="line"><span class="meta">... </span>                    params(name=<span class="string">&#x27;ed&#x27;</span>).<span class="built_in">all</span>()</span><br><span class="line">[&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;f8s7ccs&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p><code>Query</code> 定义了一个很方便的计数函数 <code>count()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(User).<span class="built_in">filter</span>(User.name.like(<span class="string">&#x27;%ed&#x27;</span>)).count()</span><br><span class="line">SELECT count(*) AS count_1</span><br><span class="line">FROM (SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">                users.name AS users_name,</span><br><span class="line">                users.fullname AS users_fullname,</span><br><span class="line">                users.password AS users_password</span><br><span class="line">FROM users</span><br><span class="line">WHERE users.name LIKE ?) AS anon_1</span><br><span class="line">(<span class="string">&#x27;%ed&#x27;</span>,)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注意上面同时列出了实际的 SQL 指令。在 SQLAlchemy 中，总是将被计数的查询打包成一个子查询，然后对这个子查询进行计数。即便是最简单的 <code>SELECT count(*) FROM table</code> ，也会如此处理。为了更精细的控制计数过程，可以采用 <code>func.count()</code> 这个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(func.count(User.name), User.name).group_by(User.name).<span class="built_in">all</span>()</span><br><span class="line">SELECT count(users.name) AS count_1, users.name AS users_name</span><br><span class="line">FROM users GROUP BY users.name</span><br><span class="line">()</span><br><span class="line">[(<span class="number">1</span>, <span class="string">u&#x27;ed&#x27;</span>), (<span class="number">1</span>, <span class="string">u&#x27;fred&#x27;</span>), (<span class="number">1</span>, <span class="string">u&#x27;mary&#x27;</span>), (<span class="number">1</span>, <span class="string">u&#x27;wendy&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>为了实现最简单的 <code>SELECT count(*) FROM table</code>，可以如下调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(func.count(<span class="string">&#x27;*&#x27;</span>)).select_from(User).scalar()</span><br><span class="line">SELECT count(?) AS count_1</span><br><span class="line">FROM users</span><br><span class="line">(<span class="string">&#x27;*&#x27;</span>,)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>如果对 <code>User</code> 的主键进行计数，那么 <code>select_from</code> 也可以省略。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(func.count(User.<span class="built_in">id</span>)).scalar()</span><br><span class="line">SELECT count(users.<span class="built_in">id</span>) AS count_1</span><br><span class="line">FROM users</span><br><span class="line">()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="关系-Relationship"><a href="#关系-Relationship" class="headerlink" title="关系(Relationship)"></a>关系(Relationship)</h2><p>『关系』是关系型数据库的一大特色，是在建模过程中的一个重要的抽象过程。</p>
<h3 id="建立关系"><a href="#建立关系" class="headerlink" title="建立关系"></a>建立关系</h3><p>之前已经建立了一个用户( User )表，现在考虑增加一个与用户关联的新的表。在系统里面，用户可以存储多个与之相关的 email 地址。这是一种基本的一对多的关系。这个新增加的存储 email 地址的表称为 <code>addresses</code>。应用 Declarative，按照如下方式定义这个新表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> ForeignKey</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> relationship</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;addresses&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    email_address = Column(String, nullable=<span class="literal">False</span>)</span><br><span class="line">    user_id = Column(Integer, ForeignKey(<span class="string">&#x27;users.id&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    user = relationship(<span class="string">&quot;User&quot;</span>, back_populates=<span class="string">&quot;addresses&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;Address(email_address=&#x27;%s&#x27;)&gt;&quot;</span> % self.email_address</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.addresses = relationship(</span><br><span class="line">        <span class="string">&quot;Address&quot;</span>, order_by=Address.<span class="built_in">id</span>, back_populates=<span class="string">&quot;user&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码中使用了一个新的名为 <code>ForeignKey</code> 的构造。其含义为，其所在的列的值域应当被限制在另一个表的指定列的取值范围之类。这一特性是关系型数据库的核心特性之一。就上例而言，<code>addresses.user_id</code> 这一列的取值范围，应当包含在 <code>users.id</code> 的取值范围之内。</p>
<p>除了 <code>ForeignKey</code> 之外，还引入了一个 <code>relationship</code>，来告诉ORM，<code>Address</code> 类需要被连接到 <code>User</code> 类。 <code>relationship</code> 和 <code>ForeignKey</code> 这个两个属性决定了表之间关系的属性，决定了这个关系是多对一的。</p>
<p>在完成对 <code>Address</code> 类的声明之后，还定义另一个 <code>relationship</code>，将其赋值给了 <code>User.addresses</code>。在两个<code>relationship</code> 中，都有传入了一个 <code>relationship.back_populates</code> 的属性来为反向关系所对应的属性进行命名。</p>
<p>多对一的关系的反向永远都是一对多的关系。关于更多的 <code>relationship()</code> 的配置方法，可以参见这个链接<a target="_blank" rel="noopener" href="http://docs.sqlalchemy.org/en/rel_1_0/orm/basic_relationships.html#relationship-patterns">Basic Relationship Patterns</a>。</p>
<p>上述我们定义的两个互补的关系 <code>Address.user</code> 和 <code>User.addresses</code> 被称为双向关系( <a target="_blank" rel="noopener" href="http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-bidirectional-relationship">bidirectional relationship</a> )，这是 SQLAlchemy 的核心特性这一。</p>
<p><code>relationship()</code> 的参数配置中指向被连接的类的字符串，可以指向工程中任何位置所定义的，基于<code>declarative base</code> 的类，而无先后之分。Declarative 会在完成所有的映射以后的将这些字符串转换为适当的、实际使用的参数形式。</p>
<h3 id="使用关联对象"><a href="#使用关联对象" class="headerlink" title="使用关联对象"></a>使用关联对象</h3><p>现在，当创建一个 <code>User</code> 实例的时候，会同时创建一个空的 <code>addresses</code> 的 collection。这个 collection 可能是多种类型，如 list, set, 或是 dictionary。默认情况下，其应当为一个 Python 列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack = User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>此时可以自由的向这个列表里面插入 <code>User</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses = [</span><br><span class="line"><span class="meta">... </span>                Address(email_address=<span class="string">&#x27;jack@google.com&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>                Address(email_address=<span class="string">&#x27;j25@yahoo.com&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>当使用 bidirectional relationship 时，通过其中一个方向的关系（如上例）会自动出现在另一个方向的关系上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses[<span class="number">1</span>]</span><br><span class="line">&lt;Address(email_address=<span class="string">&#x27;j25@yahoo.com&#x27;</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses[<span class="number">1</span>].user</span><br><span class="line">&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>把 jack 添加进入 <code>Session</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(jack)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.commit()</span><br><span class="line">INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)</span><br><span class="line">(<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;Jack Bean&#x27;</span>, <span class="string">&#x27;gjffdd&#x27;</span>)</span><br><span class="line">INSERT INTO addresses (email_address, user_id) VALUES (?, ?)</span><br><span class="line">(<span class="string">&#x27;jack@google.com&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">INSERT INTO addresses (email_address, user_id) VALUES (?, ?)</span><br><span class="line">(<span class="string">&#x27;j25@yahoo.com&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<p>可以发现上面执行了三个 <code>INSERT</code> 命令，也就是说与 jack 关联的两个 <code>Address</code> 对象也被提交了。现在通过查询来取出jack。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack = session.query(User).filter_by(name=<span class="string">&#x27;jack&#x27;</span>).one()</span><br><span class="line">BEGIN (implicit)</span><br><span class="line">SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">        users.name AS users_name,</span><br><span class="line">        users.fullname AS users_fullname,</span><br><span class="line">        users.password AS users_password</span><br><span class="line">FROM users</span><br><span class="line">WHERE users.name = ?</span><br><span class="line">(<span class="string">&#x27;jack&#x27;</span>,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack</span><br><span class="line">&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现目前只有针对 <code>User</code> 表的查询，而没有对 <code>Address</code> 表的查询。此时访问 <code>addresses</code> 属性，相关的SQL才会执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses</span><br><span class="line">SELECT addresses.<span class="built_in">id</span> AS addresses_id,</span><br><span class="line">        addresses.email_address AS</span><br><span class="line">        addresses_email_address,</span><br><span class="line">        addresses.user_id AS addresses_user_id</span><br><span class="line">FROM addresses</span><br><span class="line">WHERE ? = addresses.user_id ORDER BY addresses.id</span><br><span class="line">(<span class="number">5</span>,)</span><br><span class="line">[&lt;Address(email_address=<span class="string">&#x27;jack@google.com&#x27;</span>)&gt;, &lt;Address(email_address=<span class="string">&#x27;j25@yahoo.com&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure>
<p>上面这种方式我们称之为 <a target="_blank" rel="noopener" href="http://docs.sqlalchemy.org/en/rel_1_0/glossary.html#term-lazy-loading">lazy loading</a> ,其实还可以在查询时就加载</p>
<h4 id="joinedload"><a href="#joinedload" class="headerlink" title="joinedload"></a><a target="_blank" rel="noopener" href="https://www.osgeo.cn/sqlalchemy/orm/loading_relationships.html">joinedload</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack = session.query(User).options(joinedload(User.addresses)).\</span><br><span class="line">    filter_by(name=<span class="string">&#x27;jack&#x27;</span>).one()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses</span><br><span class="line">[&lt;Address(email_address=<span class="string">&#x27;jack@google.com&#x27;</span>)&gt;, &lt;Address(email_address=<span class="string">&#x27;j25@yahoo.com&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="使用join进行查询"><a href="#使用join进行查询" class="headerlink" title="使用join进行查询"></a>使用join进行查询</h3><p>现在有了两个彼此关联的数据表了</p>
<p>为了在 <code>User</code> 和 <code>Address</code> 之间构造一个简单的 join，可以通过 <code>Query.filter()</code> 来连接其相关列（本质是隐式写法的JOIN）。下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> u, a <span class="keyword">in</span> session.query(User, Address).\</span><br><span class="line"><span class="meta">... </span>                    <span class="built_in">filter</span>(User.<span class="built_in">id</span>==Address.user_id).\</span><br><span class="line"><span class="meta">... </span>                    <span class="built_in">filter</span>(Address.email_address==<span class="string">&#x27;jack@google.com&#x27;</span>).\</span><br><span class="line"><span class="meta">... </span>                    <span class="built_in">all</span>():</span><br><span class="line"><span class="meta">... </span>    print(u)</span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line">&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt;</span><br><span class="line">&lt;Address(email_address=<span class="string">&#x27;jack@google.com&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>而实际的 SQL JOIN 语法，可以通过 <code>Query.join()</code> 来想实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(User).join(Address).\</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">filter</span>(Address.email_address==<span class="string">&#x27;jack@google.com&#x27;</span>).\</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">all</span>()</span><br><span class="line">users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">        users.name AS users_name,</span><br><span class="line">        users.fullname AS users_fullname,</span><br><span class="line">        users.password AS users_password</span><br><span class="line">FROM users JOIN addresses ON users.<span class="built_in">id</span> = addresses.user_id</span><br><span class="line">WHERE addresses.email_address = ?</span><br><span class="line">(<span class="string">&#x27;jack@google.com&#x27;</span>,)</span><br><span class="line">[&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure>
<p>在上面的例子中由于只存在一个 ForeignKey，<code>Query.join</code> 知道如何选取合适的列进行JOIN。如果没有定义ForeignKey，或者存在多个，此时你需要手动指明你参与 JOIN 的列。<code>Query.join()</code> 以如下方式进行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query.join(Address, User.<span class="built_in">id</span>==Address.user_id)    <span class="comment"># 显式条件</span></span><br><span class="line">query.join(User.addresses)                       <span class="comment"># 指定从左到右的关系</span></span><br><span class="line">query.join(Address, User.addresses)              <span class="comment"># 相同，有明确的目标</span></span><br><span class="line">query.join(<span class="string">&#x27;addresses&#x27;</span>)  </span><br></pre></td></tr></table></figure>
<p>对于 OUTER JOIN，只需要使用 <code>Query.outerjoin()</code> 就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.outerjoin(User.addresses)   <span class="comment"># 左外连接</span></span><br></pre></td></tr></table></figure>
<p>关于 <code>join()</code> 更为详细的用法，还是请参考 <a target="_blank" rel="noopener" href="http://docs.sqlalchemy.org/en/rel_1_0/orm/query.html#sqlalchemy.orm.query.Query.join">join 官方文档</a></p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>当查询涉及多个表，而其中同一个表出现了多次时，此时需要为重复的表创建一个别名来避免冲突。下面是关于 <code>aliased</code> 的一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> aliased</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adalias1 = aliased(Address)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adalias2 = aliased(Address)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> username, email1, email2 <span class="keyword">in</span> \</span><br><span class="line"><span class="meta">... </span>    session.query(User.name, adalias1.email_address, adalias2.email_address).\</span><br><span class="line"><span class="meta">... </span>    join(adalias1, User.addresses).\</span><br><span class="line"><span class="meta">... </span>    join(adalias2, User.addresses).\</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">filter</span>(adalias1.email_address==<span class="string">&#x27;jack@google.com&#x27;</span>).\</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">filter</span>(adalias2.email_address==<span class="string">&#x27;j25@yahoo.com&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    print(username, email1, email2)</span><br><span class="line">SELECT users.name AS users_name,</span><br><span class="line">        addresses_1.email_address AS addresses_1_email_address,</span><br><span class="line">        addresses_2.email_address AS addresses_2_email_address</span><br><span class="line">FROM users JOIN addresses AS addresses_1</span><br><span class="line">        ON users.<span class="built_in">id</span> = addresses_1.user_id</span><br><span class="line">JOIN addresses AS addresses_2</span><br><span class="line">        ON users.<span class="built_in">id</span> = addresses_2.user_id</span><br><span class="line">WHERE addresses_1.email_address = ?</span><br><span class="line">        AND addresses_2.email_address = ?</span><br><span class="line">(<span class="string">&#x27;jack@google.com&#x27;</span>, <span class="string">&#x27;j25@yahoo.com&#x27;</span>)</span><br><span class="line">jack jack@google.com j25@yahoo.com</span><br></pre></td></tr></table></figure>
<h4 id="使用子查询-Subqueries"><a href="#使用子查询-Subqueries" class="headerlink" title="使用子查询(Subqueries)"></a>使用子查询(Subqueries)</h4><p><code>Query</code> 适合于用来构造子查询。假如想要取出 <code>User</code> 记录，并且同时计算各个用户的 <code>Address</code> 的数量。产生这种功能的 SQL 指令最好的办法是按照 user 的 id 分组统计地址的数量，然后 join 到外层查询。此时需要 LEFT JOIN，这样可以使得没有地址的用户也会出现在查询结果中（地址数量为0）。 </p>
<p>期望的SQL命令是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.<span class="operator">*</span>, adr_count.address_count <span class="keyword">FROM</span> users <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> user_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> address_count</span><br><span class="line">        <span class="keyword">FROM</span> addresses <span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id) <span class="keyword">AS</span> adr_count</span><br><span class="line">    <span class="keyword">ON</span> users.id<span class="operator">=</span>adr_count.user_id</span><br></pre></td></tr></table></figure>
<p>使用 <code>Query</code>，可以从内到外来构造上面的语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.sql <span class="keyword">import</span> func</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stmt = session.query(Address.user_id, func.count(<span class="string">&#x27;*&#x27;</span>).\</span><br><span class="line"><span class="meta">... </span>        label(<span class="string">&#x27;address_count&#x27;</span>)).\</span><br><span class="line"><span class="meta">... </span>        group_by(Address.user_id).subquery()</span><br></pre></td></tr></table></figure>
<p><code>func</code> 已经在之前就认识过了。<code>subquery()</code> 可以产生一个内嵌了 alias（是一个<code>query.statement.alias()</code>）的查询( SELECT )语句的表达。</p>
<p>当生成了 statement 之后，其完全可以视为一个 <code>Table</code> 来使用。可以通过 <code>c</code> 来访问它的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> u, count <span class="keyword">in</span> session.query(User, stmt.c.address_count).\</span><br><span class="line"><span class="meta">... </span>    outerjoin(stmt, User.<span class="built_in">id</span>==stmt.c.user_id).order_by(User.<span class="built_in">id</span>):</span><br><span class="line"><span class="meta">... </span>    print(u, count)</span><br><span class="line">SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">        users.name AS users_name,</span><br><span class="line">        users.fullname AS users_fullname,</span><br><span class="line">        users.password AS users_password,</span><br><span class="line">        anon_1.address_count AS anon_1_address_count</span><br><span class="line">FROM users LEFT OUTER JOIN</span><br><span class="line">    (SELECT addresses.user_id AS user_id, count(?) AS address_count</span><br><span class="line">    FROM addresses GROUP BY addresses.user_id) AS anon_1</span><br><span class="line">    ON users.<span class="built_in">id</span> = anon_1.user_id</span><br><span class="line">ORDER BY users.<span class="built_in">id</span></span><br><span class="line">(<span class="string">&#x27;*&#x27;</span>,)</span><br><span class="line">&lt;User(name=<span class="string">&#x27;ed&#x27;</span>, fullname=<span class="string">&#x27;Ed Jones&#x27;</span>, password=<span class="string">&#x27;f8s7ccs&#x27;</span>)&gt; <span class="literal">None</span></span><br><span class="line">&lt;User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>)&gt; <span class="literal">None</span></span><br><span class="line">&lt;User(name=<span class="string">&#x27;mary&#x27;</span>, fullname=<span class="string">&#x27;Mary Contrary&#x27;</span>, password=<span class="string">&#x27;xxg527&#x27;</span>)&gt; <span class="literal">None</span></span><br><span class="line">&lt;User(name=<span class="string">&#x27;fred&#x27;</span>, fullname=<span class="string">&#x27;Fred Flinstone&#x27;</span>, password=<span class="string">&#x27;blah&#x27;</span>)&gt; <span class="literal">None</span></span><br><span class="line">&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="从子查询中取出Entity"><a href="#从子查询中取出Entity" class="headerlink" title="从子查询中取出Entity"></a>从子查询中取出Entity</h4><p>在前一个例子中，从子查询获得的是一个临时性的 JOIN 后的表，但是这个表并未定义 ORM 中定义的 Entity。如果想将这个临时表映射到 ORM 中的类呢？此时可以使用 <code>aliased</code> 这个函数来完成这个映射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stmt = session.query(Address).\</span><br><span class="line"><span class="meta">... </span>                <span class="built_in">filter</span>(Address.email_address != <span class="string">&#x27;j25@yahoo.com&#x27;</span>).\</span><br><span class="line"><span class="meta">... </span>                subquery()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adalias = aliased(Address, stmt)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> user, address <span class="keyword">in</span> session.query(User, adalias).\</span><br><span class="line"><span class="meta">... </span>        join(adalias, User.addresses):</span><br><span class="line"><span class="meta">... </span>    print(user)</span><br><span class="line"><span class="meta">... </span>    print(address)</span><br><span class="line">SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">            users.name AS users_name,</span><br><span class="line">            users.fullname AS users_fullname,</span><br><span class="line">            users.password AS users_password,</span><br><span class="line">            anon_1.<span class="built_in">id</span> AS anon_1_id,</span><br><span class="line">            anon_1.email_address AS anon_1_email_address,</span><br><span class="line">            anon_1.user_id AS anon_1_user_id</span><br><span class="line">FROM users JOIN</span><br><span class="line">    (SELECT addresses.<span class="built_in">id</span> AS <span class="built_in">id</span>,</span><br><span class="line">            addresses.email_address AS email_address,</span><br><span class="line">            addresses.user_id AS user_id</span><br><span class="line">    FROM addresses</span><br><span class="line">    WHERE addresses.email_address != ?) AS anon_1</span><br><span class="line">    ON users.<span class="built_in">id</span> = anon_1.user_id</span><br><span class="line">(<span class="string">&#x27;j25@yahoo.com&#x27;</span>,)</span><br><span class="line">&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt;</span><br><span class="line">&lt;Address(email_address=<span class="string">&#x27;jack@google.com&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用EXISTS"><a href="#使用EXISTS" class="headerlink" title="使用EXISTS"></a>使用EXISTS</h3><p>EXISTS 关键字是一个 BOOL 型操作符。当查询结果存在至少一行时返回 True。EXISTS 可以常常和 JOIN 搭配使用。</p>
<p>下面是一个显式的 EXISTS 构造方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.sql <span class="keyword">import</span> exists</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stmt = exists().where(Address.user_id==User.<span class="built_in">id</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, <span class="keyword">in</span> session.query(User.name).<span class="built_in">filter</span>(stmt):</span><br><span class="line"><span class="meta">... </span>    print(name)</span><br><span class="line">SELECT users.name AS users_name</span><br><span class="line">FROM users</span><br><span class="line">WHERE EXISTS (SELECT *</span><br><span class="line">FROM addresses</span><br><span class="line">WHERE addresses.user_id = users.<span class="built_in">id</span>)</span><br><span class="line">()</span><br><span class="line">jack</span><br></pre></td></tr></table></figure>
<p><code>Query</code> 还定义了若干个自动使用了 EXISTS 的操作。上面的例子可以用 <code>any()</code> 来完成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, <span class="keyword">in</span> session.query(User.name).\</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">filter</span>(User.addresses.<span class="built_in">any</span>()):</span><br><span class="line"><span class="meta">... </span>    print(name)</span><br><span class="line">SELECT users.name AS users_name</span><br><span class="line">FROM users</span><br><span class="line">WHERE EXISTS (SELECT <span class="number">1</span></span><br><span class="line">FROM addresses</span><br><span class="line">WHERE users.<span class="built_in">id</span> = addresses.user_id)</span><br><span class="line">()</span><br><span class="line">jack</span><br></pre></td></tr></table></figure>
<p><code>any()</code>也接受筛选条件来限制匹配的行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, <span class="keyword">in</span> session.query(User.name).\</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">filter</span>(User.addresses.<span class="built_in">any</span>(Address.email_address.like(<span class="string">&#x27;%google%&#x27;</span>))):</span><br><span class="line"><span class="meta">... </span>    print(name)</span><br><span class="line">jack</span><br></pre></td></tr></table></figure>
<p><code>has()</code>对于的many-to-one的关系，起到的是和<code>any()</code>同样的作用（注意这里<code>~</code>表示NOT）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(Address).\</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">filter</span>(~Address.user.has(User.name==<span class="string">&#x27;jack&#x27;</span>)).<span class="built_in">all</span>()</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h3 id="常用的关系操作"><a href="#常用的关系操作" class="headerlink" title="常用的关系操作"></a>常用的关系操作</h3><p>下面只是简单的列出了一些常用的操作。</p>
<ul>
<li><p><strong>eq() (多对一“等于”):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(Address.user == someuser)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>ne() (多对一“不等于”):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(Address.user != someuser)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IS NULL (多对一比较, 用 eq()):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(Address.user == <span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>contains() (用于一对多集合):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.addresses.contains(someaddress))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>any() :</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(User.addresses.<span class="built_in">any</span>(Address.email_address == <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以接受关键字参数:</span></span><br><span class="line">query.<span class="built_in">filter</span>(User.addresses.<span class="built_in">any</span>(email_address=<span class="string">&#x27;bar&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>has() :</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">filter</span>(Address.user.has(name=<span class="string">&#x27;ed&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Query.with_parent() :</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.query(Address).with_parent(someuser, <span class="string">&#x27;addresses&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Eager-Loading"><a href="#Eager-Loading" class="headerlink" title="Eager Loading"></a>Eager Loading</h3></li>
</ul>
<p>前面当查询取出用户时，与之关联的地址并没有取出来。当试图获取 <code>User.addresses</code> 时，相关的 SQL 查询才起作用。如果想要减少 query 的次数的话，就需要使用 Eager Loading 了。SQLAlchemy 提供了三种 Eager Loading 的方式，其中两种是自动的，而第三种涉及到自定义的筛选条件。所有的这三种 Eager Loading 方式都会通过调用 <code>Query.options()</code> 来影响查询的过程，促使 <code>Query</code> 生成需要的额外配置来取出期望的内容。</p>
<h4 id="子查询加载"><a href="#子查询加载" class="headerlink" title="子查询加载"></a>子查询加载</h4><p>在上面的例子中，我们希望在取出用户的时候就同步取出对应的地址。此时可以此采用 <code>orm.subqueryload()</code>。这个函数可以发起第二个 SELECT 查询来取出与结果相关的另一个表的信息。这里取名为”<strong>子查询加载</strong>“的原因是：此处的 <code>Query </code>在发起第二个查询时作为子查询而被复用了。详细过程参加下面的程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> subqueryload</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack = session.query(User).\</span><br><span class="line"><span class="meta">... </span>                options(subqueryload(User.addresses)).\</span><br><span class="line"><span class="meta">... </span>                filter_by(name=<span class="string">&#x27;jack&#x27;</span>).one()</span><br><span class="line">SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">        users.name AS users_name,</span><br><span class="line">        users.fullname AS users_fullname,</span><br><span class="line">        users.password AS users_password</span><br><span class="line">FROM users</span><br><span class="line">WHERE users.name = ?</span><br><span class="line">(<span class="string">&#x27;jack&#x27;</span>,)</span><br><span class="line">SELECT addresses.<span class="built_in">id</span> AS addresses_id,</span><br><span class="line">        addresses.email_address AS addresses_email_address,</span><br><span class="line">        addresses.user_id AS addresses_user_id,</span><br><span class="line">        anon_1.users_id AS anon_1_users_id</span><br><span class="line">FROM (SELECT users.<span class="built_in">id</span> AS users_id</span><br><span class="line">    FROM users WHERE users.name = ?) AS anon_1</span><br><span class="line">JOIN addresses ON anon_1.users_id = addresses.user_id</span><br><span class="line">ORDER BY anon_1.users_id, addresses.<span class="built_in">id</span></span><br><span class="line">(<span class="string">&#x27;jack&#x27;</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack</span><br><span class="line">&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses</span><br><span class="line">[&lt;Address(email_address=<span class="string">&#x27;jack@google.com&#x27;</span>)&gt;, &lt;Address(email_address=<span class="string">&#x27;j25@yahoo.com&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：当 <code>subqueryload() </code>和涉及 limiting 的函数一起使用的时候（如 <code>Query.first()</code>, <code>Query.limit()</code>, <code>Query.offset()</code> 等），应当加上一个以 Unique 的行作为参数的 <code>Query.order_by()</code> 来确保结果的正确性。</p>
<h4 id="连接加载"><a href="#连接加载" class="headerlink" title="连接加载"></a>连接加载</h4><p>这种方式要更为常用一些。Joined Loading 发起了一个 JOIN（默认是LEFT OUTER JOIN），故而查询结果和制定的与之关联的行可以被同时取出。这里以和上面的Subquery Loading中同样的查询目的为例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> joinedload</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack = session.query(User).\</span><br><span class="line"><span class="meta">... </span>                       options(joinedload(User.addresses)).\</span><br><span class="line"><span class="meta">... </span>                       filter_by(name=<span class="string">&#x27;jack&#x27;</span>).one()</span><br><span class="line">SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">        users.name AS users_name,</span><br><span class="line">        users.fullname AS users_fullname,</span><br><span class="line">        users.password AS users_password,</span><br><span class="line">        addresses_1.<span class="built_in">id</span> AS addresses_1_id,</span><br><span class="line">        addresses_1.email_address AS addresses_1_email_address,</span><br><span class="line">        addresses_1.user_id AS addresses_1_user_id</span><br><span class="line">FROM users</span><br><span class="line">    LEFT OUTER JOIN addresses AS addresses_1 ON users.<span class="built_in">id</span> = addresses_1.user_id</span><br><span class="line">WHERE users.name = ? ORDER BY addresses_1.id</span><br><span class="line">(<span class="string">&#x27;jack&#x27;</span>,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack</span><br><span class="line">&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack.addresses</span><br><span class="line">[&lt;Address(email_address=<span class="string">&#x27;jack@google.com&#x27;</span>)&gt;, &lt;Address(email_address=<span class="string">&#x27;j25@yahoo.com&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，如果是在命令行运行了前一个 Subquery Loading 的例子的话，在这里 jack 的 addresses 实际上已经填充了的，但是这里的 Joined Load 仍然是会发起 JOIN。另外，LEFT OUTER JOIN 指令实际上有可能导致重复的User出现，但是在结果中实际得到的 User 却不会重复。这是因为 <code>Query</code> 实际上是基于 Object Identity 采用了一种 “uniquing” 的策略。</p>
<p><code>joinedload()</code> 出现的更早一些。<code>joinedloading()</code> 更加适合于处理Many-to-one的关系。</p>
<h4 id="显式的Join-EagerLoad"><a href="#显式的Join-EagerLoad" class="headerlink" title="显式的Join + EagerLoad"></a>显式的Join + EagerLoad</h4><p>第三种方式是自己显式的调用 join 来定位 JOIN 连接主键，并接着关联表的信息填充到查询结果中对应对象或者列表中。这个特性需要使用到 <code>orm.contains_eager()</code> 函数。这个机制最典型的用途是 pre-loading many-to-one 关系，同时添加对这个关系的筛选。</p>
<p>假设我们需要筛选出用户的名字为jack的邮件地址，进行这个查询的方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> contains_eager</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jacks_addresses = session.query(Address).\</span><br><span class="line"><span class="meta">... </span>                            join(Address.user).\</span><br><span class="line"><span class="meta">... </span>                            <span class="built_in">filter</span>(User.name==<span class="string">&#x27;jack&#x27;</span>).\</span><br><span class="line"><span class="meta">... </span>                            options(contains_eager(Address.user)).\</span><br><span class="line"><span class="meta">... </span>                            <span class="built_in">all</span>()</span><br><span class="line">SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">        users.name AS users_name,</span><br><span class="line">        users.fullname AS users_fullname,</span><br><span class="line">        users.password AS users_password,</span><br><span class="line">        addresses.<span class="built_in">id</span> AS addresses_id,</span><br><span class="line">        addresses.email_address AS addresses_email_address,</span><br><span class="line">        addresses.user_id AS addresses_user_id</span><br><span class="line">FROM addresses JOIN users ON users.<span class="built_in">id</span> = addresses.user_id</span><br><span class="line">WHERE users.name = ?</span><br><span class="line">(<span class="string">&#x27;jack&#x27;</span>,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jacks_addresses</span><br><span class="line">[&lt;Address(email_address=<span class="string">&#x27;jack@google.com&#x27;</span>)&gt;, &lt;Address(email_address=<span class="string">&#x27;j25@yahoo.com&#x27;</span>)&gt;]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jacks_addresses[<span class="number">0</span>].user</span><br><span class="line">&lt;User(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Bean&#x27;</span>, password=<span class="string">&#x27;gjffdd&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<h3 id="关系中的删除问题"><a href="#关系中的删除问题" class="headerlink" title="关系中的删除问题"></a>关系中的删除问题</h3><p>尝试删除jack，来看结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.delete(jack)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(User).filter_by(name=<span class="string">&#x27;jack&#x27;</span>).count()</span><br><span class="line">UPDATE addresses SET user_id=? WHERE addresses.id = ?</span><br><span class="line">((<span class="literal">None</span>, <span class="number">1</span>), (<span class="literal">None</span>, <span class="number">2</span>))</span><br><span class="line">DELETE FROM users WHERE users.id = ?</span><br><span class="line">(<span class="number">5</span>,)</span><br><span class="line">SELECT count(*) AS count_1</span><br><span class="line">FROM (SELECT users.<span class="built_in">id</span> AS users_id,</span><br><span class="line">        users.name AS users_name,</span><br><span class="line">        users.fullname AS users_fullname,</span><br><span class="line">        users.password AS users_password</span><br><span class="line">FROM users</span><br><span class="line">WHERE users.name = ?) AS anon_1</span><br><span class="line">(<span class="string">&#x27;jack&#x27;</span>,)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>那么与jack关联的地址呢?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(Address).<span class="built_in">filter</span>(</span><br><span class="line"><span class="meta">... </span>    Address.email_address.in_([<span class="string">&#x27;jack@google.com&#x27;</span>, <span class="string">&#x27;j25@yahoo.com&#x27;</span>])</span><br><span class="line"><span class="meta">... </span> ).count()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>地址记录仍然在这里。如果 commit 的话，可以从上面的 SQL 语句中发现，相关的 <code>Address</code> 的 <code>user_id</code> 属性被设置成了NULL。这不符合要求。这就需要自己来设置关系的删除规则。</p>
<h4 id="配置delete-delete-orphan-Cascade"><a href="#配置delete-delete-orphan-Cascade" class="headerlink" title="配置delete/delete-orphan Cascade"></a>配置delete/delete-orphan Cascade</h4><p>通过配置 <code>User.addresses</code> 关系的 <strong>cascade</strong> 选项来控制删除行为。尽管 SQLAlchemy 允许你在任何时候给 ORM 添加属性或者关系。此时还是需要移除现存的关系并且重新开始。</p>
<p>首先关闭当前的session</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.close()</span><br></pre></td></tr></table></figure>
<p>使用一个新的 <code>declarative_base()</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Base = declarative_base()</span><br></pre></td></tr></table></figure>
<p>下面重新声明 <code>User</code> 类，注意 <code>addresses</code> 中的配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String)</span><br><span class="line">    fullname = Column(String)</span><br><span class="line">    password = Column(String)</span><br><span class="line"></span><br><span class="line">    addresses = relationship(<span class="string">&quot;Address&quot;</span>, back_populates=<span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">                        cascade=<span class="string">&quot;all, delete, delete-orphan&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;User(name=&#x27;%s&#x27;, fullname=&#x27;%s&#x27;, password=&#x27;%s&#x27;)&gt;&quot;</span> % (</span><br><span class="line">                               self.name, self.fullname, self.password)</span><br></pre></td></tr></table></figure>
<p>接下来重新声明 <code>Address</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;addresses&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    email_address = Column(String, nullable=<span class="literal">False</span>)</span><br><span class="line">    user_id = Column(Integer, ForeignKey(<span class="string">&#x27;users.id&#x27;</span>))</span><br><span class="line">    user = relationship(<span class="string">&quot;User&quot;</span>, back_populates=<span class="string">&quot;addresses&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;Address(email_address=&#x27;%s&#x27;)&gt;&quot;</span> % self.email_address</span><br></pre></td></tr></table></figure>
<p>现在取出 jack(下面使用了一个之前没有提到的函数 <code>get()</code>，其参数为查询目标的主键)，现在从 <code>addresses</code> 中删除一个地址的话，会导致这个 <code>Address</code> 被删除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jack = session.query(User).get(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> jack.addresses[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(Address).<span class="built_in">filter</span>(</span><br><span class="line"><span class="meta">... </span>    Address.email_address.in_([<span class="string">&#x27;jack@google.com&#x27;</span>, <span class="string">&#x27;j25@yahoo.com&#x27;</span>])</span><br><span class="line"><span class="meta">... </span>).count()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>删除 jack 也会导致剩下 jack 以及其所有的 <code>Address</code> 都会被删除:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; session.delete(jack)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(User).filter_by(name=<span class="string">&#x27;jack&#x27;</span>).count()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(Address).<span class="built_in">filter</span>(</span><br><span class="line"><span class="meta">... </span>   Address.email_address.in_([<span class="string">&#x27;jack@google.com&#x27;</span>, <span class="string">&#x27;j25@yahoo.com&#x27;</span>])</span><br><span class="line"><span class="meta">... </span>).count()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="建立多对多关系ManyToMany-Relationship"><a href="#建立多对多关系ManyToMany-Relationship" class="headerlink" title="建立多对多关系ManyToMany Relationship"></a>建立多对多关系ManyToMany Relationship</h3><p>现在需要引入一个新的模型来阐述多对多的关系了。假设需要完成一个博客应用。在这个应用里面我们可以书写<code>BlogPost</code>，每个博客都有若干 <code>Keyword</code>。</p>
<p>对于一个多对多的关系，需要建立一个未映射的（也就是没有一个 Python 类与之对应的）表 <code>Table</code> 来作为中间联系的表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, Text</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post_keywords = Table(<span class="string">&#x27;post_keywords&#x27;</span>, Base.metadata,</span><br><span class="line"><span class="meta">... </span>    Column(<span class="string">&#x27;post_id&#x27;</span>, ForeignKey(<span class="string">&#x27;posts.id&#x27;</span>), primary_key=<span class="literal">True</span>),</span><br><span class="line"><span class="meta">... </span>    Column(<span class="string">&#x27;keyword_id&#x27;</span>, ForeignKey(<span class="string">&#x27;keywords.id&#x27;</span>), primary_key=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span>)</span><br></pre></td></tr></table></figure>
<p>不同于之前的典型的ORM方法，在上面的代码中直接声明了一个 <code>Table</code>，而没有制定与之对应的 Python 类。<code>Table</code> 是一个构造函数，其参数中的每个 <code>Colomn</code> 以逗号分隔。</p>
<p>下面来定义 <code>BlogPost</code> 和 <code>Keyword</code>。这里需要使用 <code>relationship()</code> 在这两个类中定义一对互补的关系，其中每个关系的都指向 <code>post_keyword</code> 这个表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;posts&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    user_id = Column(Integer, ForeignKey(<span class="string">&#x27;users.id&#x27;</span>))</span><br><span class="line">    headline = Column(String(<span class="number">255</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    body = Column(Text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># many to many BlogPost&lt;-&gt;Keyword</span></span><br><span class="line">    keywords = relationship(<span class="string">&#x27;Keyword&#x27;</span>,</span><br><span class="line">                            secondary=post_keywords,</span><br><span class="line">                            back_populates=<span class="string">&#x27;posts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, headline, body, author</span>):</span></span><br><span class="line">        self.author = author</span><br><span class="line">        self.headline = headline</span><br><span class="line">        self.body = body</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BlogPost(%r, %r, %r)&quot;</span> % (self.headline, self.body, self.author)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyword</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;keywords&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    keyword = Column(String(<span class="number">50</span>), nullable=<span class="literal">False</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    posts = relationship(<span class="string">&#x27;BlogPost&#x27;</span>,</span><br><span class="line">                         secondary=post_keywords,</span><br><span class="line">                         back_populates=<span class="string">&#x27;keywords&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, keyword</span>):</span></span><br><span class="line">        self.keyword = keyword</span><br></pre></td></tr></table></figure>
<p>在上面的定义中，可以发现和 One-To-Many关系不同，<code>relationship()</code> 中多了一个 <code>secondary</code> 的参数，这个参数指向了中间表。这个中间表只包含了指向多对多关系两侧的表的主键的列。如果这个表包含了其他属性，甚至是自身的主键，SQLAlchemy 需要你使用另一种，称为 <code>association object</code> 的机制来处理。</p>
<p>还希望的 <code>BlogPost</code> 能够拥有一个 <code>author</code> 属性，这个属性指向先前定义的 <code>User</code>。此时需要再定义一个双向关系。由于一个作者可能拥有很多文章，访问 <code>User.posts </code>的时候可以加以筛选而不是载入全部的相关文章。为此在定义 <code>User.posts</code> 的时候，设置 <code>lazy=&#39;dynamic&#39;</code>，来控制载入策略。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BlogPost.author = relationship(User, back_populates=<span class="string">&quot;posts&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.posts = relationship(BlogPost, back_populates=<span class="string">&quot;author&quot;</span>, lazy=<span class="string">&quot;dynamic&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后创建数据库中对应的表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Base.metadata.create_all(engine)</span><br><span class="line">PRAGMA...</span><br><span class="line">CREATE TABLE keywords (</span><br><span class="line">    <span class="built_in">id</span> INTEGER NOT NULL,</span><br><span class="line">    keyword VARCHAR(<span class="number">50</span>) NOT NULL,</span><br><span class="line">    PRIMARY KEY (<span class="built_in">id</span>),</span><br><span class="line">    UNIQUE (keyword)</span><br><span class="line">)</span><br><span class="line">()</span><br><span class="line">COMMIT</span><br><span class="line">CREATE TABLE posts (</span><br><span class="line">    <span class="built_in">id</span> INTEGER NOT NULL,</span><br><span class="line">    user_id INTEGER,</span><br><span class="line">    headline VARCHAR(<span class="number">255</span>) NOT NULL,</span><br><span class="line">    body TEXT,</span><br><span class="line">    PRIMARY KEY (<span class="built_in">id</span>),</span><br><span class="line">    FOREIGN KEY(user_id) REFERENCES users (<span class="built_in">id</span>)</span><br><span class="line">)</span><br><span class="line">()</span><br><span class="line">COMMIT</span><br><span class="line">CREATE TABLE post_keywords (</span><br><span class="line">    post_id INTEGER NOT NULL,</span><br><span class="line">    keyword_id INTEGER NOT NULL,</span><br><span class="line">    PRIMARY KEY (post_id, keyword_id),</span><br><span class="line">    FOREIGN KEY(post_id) REFERENCES posts (<span class="built_in">id</span>),</span><br><span class="line">    FOREIGN KEY(keyword_id) REFERENCES keywords (<span class="built_in">id</span>)</span><br><span class="line">)</span><br><span class="line">()</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<p>多对多关系的使用方法道也没有太大的不同之处。先来给windy添加博文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>wendy = session.query(User).\</span><br><span class="line"><span class="meta">... </span>                filter_by(name=<span class="string">&#x27;wendy&#x27;</span>).\</span><br><span class="line"><span class="meta">... </span>                one()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post = BlogPost(<span class="string">&quot;Wendy&#x27;s Blog Post&quot;</span>, <span class="string">&quot;This is a test&quot;</span>, wendy)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(post)</span><br></pre></td></tr></table></figure>
<p>给博文添加一些关键字。目前数据库里面还没有关键字存在，先创建一些：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.keywords.append(Keyword(<span class="string">&#x27;wendy&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.keywords.append(Keyword(<span class="string">&#x27;firstpost&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>此时可以开始查询了。先以 ‘firstpost’ 为关键字来检索所有的博文。使用 <code>any</code> 来查询拥有关键词 ‘firstpost’ 的博文：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(BlogPost).\</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">filter</span>(BlogPost.keywords.<span class="built_in">any</span>(keyword=<span class="string">&#x27;firstpost&#x27;</span>)).\</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">all</span>()</span><br><span class="line">[BlogPost(<span class="string">&quot;Wendy&#x27;s Blog Post&quot;</span>, <span class="string">&#x27;This is a test&#x27;</span>, &lt;User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>)&gt;)]</span><br></pre></td></tr></table></figure>
<p>如果希望将查询范围限制在wendy用户所拥有的博文之内，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>session.query(BlogPost).\</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">filter</span>(BlogPost.author==wendy).\</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">filter</span>(BlogPost.keywords.<span class="built_in">any</span>(keyword=<span class="string">&#x27;firstpost&#x27;</span>)).\</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">all</span>()</span><br><span class="line">SELECT posts.<span class="built_in">id</span> AS posts_id,</span><br><span class="line">        posts.user_id AS posts_user_id,</span><br><span class="line">        posts.headline AS posts_headline,</span><br><span class="line">        posts.body AS posts_body</span><br><span class="line">FROM posts</span><br><span class="line">WHERE ? = posts.user_id AND (EXISTS (SELECT 1</span><br><span class="line">    FROM post_keywords, keywords</span><br><span class="line">    WHERE posts.<span class="built_in">id</span> = post_keywords.post_id</span><br><span class="line">        AND keywords.<span class="built_in">id</span> = post_keywords.keyword_id</span><br><span class="line">        AND keywords.keyword = ?))</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;firstpost&#x27;</span>)</span><br><span class="line">[BlogPost(<span class="string">&quot;Wendy&#x27;s Blog Post&quot;</span>, <span class="string">&#x27;This is a test&#x27;</span>, &lt;User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>)&gt;)]</span><br></pre></td></tr></table></figure>
<p>或者可以直接在wendy的<code>posts</code>属性上进行查询：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>wendy.posts.\</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">filter</span>(BlogPost.keywords.<span class="built_in">any</span>(keyword=<span class="string">&#x27;firstpost&#x27;</span>)).\</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">all</span>()</span><br><span class="line">[BlogPost(<span class="string">&quot;Wendy&#x27;s Blog Post&quot;</span>, <span class="string">&#x27;This is a test&#x27;</span>, &lt;User(name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>, password=<span class="string">&#x27;foobar&#x27;</span>)&gt;)]</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.zhangjie.me/2021/07/19/SQLAlchemyORM/">https://blog.zhangjie.me/2021/07/19/SQLAlchemyORM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.zhangjie.me">JieのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/09/go-study-01/"><i class="fa fa-chevron-left">  </i><span>Golang 学习笔记</span></a></div><div class="next-post pull-right"><a href="/2021/03/29/fastapi-study-six/"><span>FastAPI(六)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'rWbNhLP6dd03QHWRmTsOzEyJ-9Nh9j0Va',
  appKey:'xODfIUNMglVzANEwiXfChs82',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/images/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Jie</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>